<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>nextTick事件原理 | blog-demo</title>
    <meta name="description" content="Vuepress blog demo">
    
    
    <link rel="preload" href="/serina/assets/css/0.styles.86984680.css" as="style"><link rel="preload" href="/serina/assets/js/app.f947d9ec.js" as="script"><link rel="preload" href="/serina/assets/js/2.92704444.js" as="script"><link rel="preload" href="/serina/assets/js/10.b2a1b0fd.js" as="script"><link rel="prefetch" href="/serina/assets/js/11.d30d929d.js"><link rel="prefetch" href="/serina/assets/js/12.c4eaabda.js"><link rel="prefetch" href="/serina/assets/js/13.4d945e46.js"><link rel="prefetch" href="/serina/assets/js/14.1d643e5a.js"><link rel="prefetch" href="/serina/assets/js/3.ab23ac55.js"><link rel="prefetch" href="/serina/assets/js/4.59116900.js"><link rel="prefetch" href="/serina/assets/js/5.12145d41.js"><link rel="prefetch" href="/serina/assets/js/6.f04469d3.js"><link rel="prefetch" href="/serina/assets/js/7.1114215c.js"><link rel="prefetch" href="/serina/assets/js/8.c4671aee.js"><link rel="prefetch" href="/serina/assets/js/9.1a61cfc3.js">
    <link rel="stylesheet" href="/serina/assets/css/0.styles.86984680.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/serina/" class="home-link router-link-active"><!----> <span class="site-name">blog-demo</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/serina/blog/javascript/" class="nav-link router-link-active">Home</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="博客" class="dropdown-title"><span class="title">博客</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/serina/blog/javascript/" class="nav-link router-link-active">JavaScript</a></li><li class="dropdown-item"><!----> <a href="/serina/blog/typescript/" class="nav-link">TypeScript</a></li><li class="dropdown-item"><!----> <a href="/serina/blog/css/" class="nav-link">CSS</a></li></ul></div></div> <a href="https://github.com/duyu123/serina.git" target="_blank" rel="noopener noreferrer" class="repo-link">
    My GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/serina/blog/javascript/" class="nav-link router-link-active">Home</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="博客" class="dropdown-title"><span class="title">博客</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/serina/blog/javascript/" class="nav-link router-link-active">JavaScript</a></li><li class="dropdown-item"><!----> <a href="/serina/blog/typescript/" class="nav-link">TypeScript</a></li><li class="dropdown-item"><!----> <a href="/serina/blog/css/" class="nav-link">CSS</a></li></ul></div></div> <a href="https://github.com/duyu123/serina.git" target="_blank" rel="noopener noreferrer" class="repo-link">
    My GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>JavaScript</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/serina/blog/javascript/javascript1.html" class="sidebar-link">D3圆饼图</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Vue</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/serina/blog/javascript/vue-nextTick.html" class="active sidebar-link">nextTick事件原理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/serina/blog/javascript/vue-nextTick.html#概述" class="sidebar-link">概述</a></li><li class="sidebar-sub-header"><a href="/serina/blog/javascript/vue-nextTick.html#详细着说" class="sidebar-link">详细着说</a></li><li class="sidebar-sub-header"><a href="/serina/blog/javascript/vue-nextTick.html#浏览器" class="sidebar-link">浏览器</a></li><li class="sidebar-sub-header"><a href="/serina/blog/javascript/vue-nextTick.html#参考" class="sidebar-link">参考</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>nextTick实现原理</p></div> <h2 id="概述"><a href="#概述" class="header-anchor">#</a> 概述</h2> <img src="/serina/16ab1b0523456e8a.png" alt="foo"> <h3 id="vue官方对nexttick这个api的描述"><a href="#vue官方对nexttick这个api的描述" class="header-anchor">#</a> Vue官方对nextTick这个API的描述</h3> <blockquote><p>在下次DOM更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的DOM。</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 修改数据</span>
vm<span class="token punctuation">.</span>msg <span class="token operator">=</span> <span class="token string">'Hello'</span>
<span class="token comment">// DOM 还没有更新</span>
Vue<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// DOM 更新了</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 作为一个 Promise 使用 (2.1.0 起新增，详见接下来的提示)</span>
Vue<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// DOM 更新了</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

</code></pre></div><blockquote><p>2.1.0 起新增：如果没有提供回调且在支持 Promise 的环境中，则返回一个 Promise。请注意 Vue 不自带 Promise 的 polyfill，所以如果你的目标浏览器不原生支持 Promise (IE：你们都看我干嘛)，你得自己提供 polyfill。</p></blockquote> <blockquote><p>可能你还没有注意到，Vue 异步执行 DOM 更新。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部尝试对异步队列使用原生的 Promise.then 和 MessageChannel，如果执行环境不支持，会采用 setTimeout(fn, 0) 代替。</p></blockquote> <blockquote><p>例如，当你设置 vm.someData = 'new value' ，该组件不会立即重新渲染。当刷新队列时，组件会在事件循环队列清空时的下一个“tick”更新。多数情况我们不需要关心这个过程，但是如果你想在 DOM 状态更新后做点什么，这就可能会有些棘手。虽然 Vue.js 通常鼓励开发人员沿着“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们确实要这么做。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用 Vue.nextTick(callback) 。这样回调函数在 DOM 更新完成后就会调用。</p></blockquote> <p>Vue对于这个API的感情是曲折的，在2.4版本、2.5版本和2.6版本中对于nextTick进行反复变动，原因是浏览器对于微任务的不兼容性影响、微任务和宏任务各自优缺点的权衡。</p> <h4 id="上图解释"><a href="#上图解释" class="header-anchor">#</a> 上图解释</h4> <p>看以上流程图，如果Vue使用setTimeout等<strong>宏任务</strong>函数，那么势必要等待UI渲染完成后的下一个<strong>宏任务</strong>内执行，而如果Vue使用<strong>微任务</strong>,无需等待UI渲染完成才进行<mark>nextTick</mark>的回调函数操作，可以想象在JS引擎线程和GUI渲染线程之间来回切换，以及等待GUI渲染线程的过程中，浏览器势必要消耗性能，这是一个严谨的框架完全需要考虑的事情。
<br>
当然这里所说的只有<mark>nextTick</mark>执行用户回调之后的性能情况考虑，这中间当权不能忽略<mark>flushBatcherQueue</mark>更新Dom的操作，使用异步函数的另外一个作用当然是要确保同步代码执行完毕Dom更新性能优化</p> <h2 id="详细着说"><a href="#详细着说" class="header-anchor">#</a> 详细着说</h2> <h3 id="vue方面"><a href="#vue方面" class="header-anchor">#</a> Vue方面</h3> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>{{number}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>handleClick<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>click<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code> <span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
    <span class="token function">data</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">{</span>
            number<span class="token punctuation">:</span> <span class="token number">0</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>
        <span class="token function">handleClick</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>number<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><p>在点击click事件之后，number会被遍历增加10000次。在Vue.js响应式系统中，可以看一下<a href="https://juejin.im/post/5b82b174518825431079d473" target="_blank" rel="noopener noreferrer">Vue.js的响应式系统原理<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。我们知道Vue.js会经历“setter-&gt;Dep-&gt;Watcher-&gt;patch-&gt;视图”这几个流程
<br></p> <p>根据以往的理解，每次number被+1的时候，都会触发number的setter按照上边的流程最后来修改真实的DOM,然后DOM被更新了10000次，想想都刺激！看一下官网的描述：<strong>Vue 异步执行 DOM 更新。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要显然。</strong></p> <p>Vue.js在修改数据的时候，不会立马修改数据，而是要等同一事件轮询的数据都更新完之后，再统一进行视图更新。</p> <div class="language-js extra-class"><pre class="language-js"><code> <span class="token comment">//改变数据</span>
vm<span class="token punctuation">.</span>message <span class="token operator">=</span> <span class="token string">'changed'</span>

<span class="token comment">//想要立即使用更新后的DOM。这样不行，因为设置message后DOM还没有更新</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$el<span class="token punctuation">.</span>textContent<span class="token punctuation">)</span> <span class="token comment">// 并不会得到'changed'</span>

<span class="token comment">//这样可以，nextTick里面的代码会在DOM更新后执行</span>
Vue<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$el<span class="token punctuation">.</span>textContent<span class="token punctuation">)</span> <span class="token comment">//可以得到'changed'</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

</code></pre></div><h6 id="图解"><a href="#图解" class="header-anchor">#</a> 图解</h6> <img src="/serina/165821ca4d06f6c1.png" alt="foo"> <h2 id="浏览器"><a href="#浏览器" class="header-anchor">#</a> 浏览器</h2> <p>浏览器（多进程）包含了<strong>Browser进程</strong>（浏览器的主进程）、<strong>第三方插件进程</strong>和<strong>GPU进程</strong>（浏览器渲染进程），其中<strong>GPU进程</strong>（多线程）和Web前端密切相关，包含以下线程：</p> <ul><li>GUI渲染线程</li> <li>JS引擎线程</li> <li>事件触发线程（和EventLoop密切相关）</li> <li>定时触发器线程</li> <li>异步HTTP请求线程</li></ul> <blockquote><p>GUI渲染线程和JS引擎线程是互斥的，为了防止DOM渲染的不一致性，其中一个线程执行时另一个线程会被挂起。</p></blockquote> <p>::: 注意
这些线程中，和Vue的nextTick息息相关的是JS引擎线程和事件触发线程。
:::</p> <h3 id="js引擎线程和事件触发线程"><a href="#js引擎线程和事件触发线程" class="header-anchor">#</a> JS引擎线程和事件触发线程</h3> <p>浏览器页面初次渲染完毕后，JS引擎线程结合事件触发线程的工作流程如下：</p> <ol><li>同步任务在JS引擎线程（主线程）上执行，形成执行栈（Execution Context Stack）。</li> <li>主线程之外，事件触发线程管理着一个任务队列（Task Queue）。只要异步任务有了运行结果，就在任务队列之中放置一个事件。</li> <li>执行栈中的同步任务执行完毕，系统就会读取任务队列，如果有异步任务需要执行，将其加到主线程的执行栈并执行相应的异步任务。</li></ol> <img src="/serina/16ab1b052294607c.png" alt="foo"> <h3 id="事件循环机制（event-loop）"><a href="#事件循环机制（event-loop）" class="header-anchor">#</a> 事件循环机制（Event Loop）</h3> <p>事件触发线程管理的任务队列是如何产生的呢？事实上这些任务就是从JS引擎线程本身产生的，主线程在运行时会产生执行栈，栈中的代码调用某些异步API时会在任务队列中添加事件，栈中的代码执行完毕后，就会读取任务队列中的事件，去执行事件对应的回调函数，如此循环往复，形成事件循环机制，如下图所示：
<img src="/serina/16ab1b0b9c0cbfa4.png" alt="foo"></p> <h3 id="任务类型"><a href="#任务类型" class="header-anchor">#</a> 任务类型</h3> <p>JS中有两种任务类型：<strong>微任务</strong>（microtask）和<strong>宏任务</strong>（macrotask），在ES6中，microtask称为 jobs，macrotask称为 task。
<br></p> <p><strong>宏任务</strong>： script （主代码块）、<mark>setTimeout</mark> 、<mark>setInterval</mark> 、<mark>setImmediate</mark> 、I/O 、UI rendering</p> <p><strong>微任务</strong>：process.nextTick（Nodejs） 、promise 、Object.observe 、MutationObserver</p> <blockquote><p>这里要重点说明一下，宏任务并非全是异步任务，主代码块就是属于宏任务的一种（Promises/A+规范）。</p></blockquote> <p>它们之间区别如下:</p> <ul><li><p>宏任务是每次执行栈执行的代码（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）</p></li> <li><p>浏览器为了能够使得JS引擎线程与GUI渲染线程有序切换，会在当前宏任务结束之后，下一个宏任务执行开始之前，对页面进行重新渲染（宏任务 &gt; 渲染 &gt; 宏任务 &gt; ...）</p></li> <li><p>微任务是在当前宏任务执行结束之后立即执行的任务（在当前 宏任务执行之后，UI渲染之前执行的任务）。微任务的响应速度相比setTimeout（下一个宏任务）会更快，因为无需等待UI渲染。</p></li> <li><p>当前宏任务执行后，会将在它执行期间产生的所有微任务都执行一遍。</p></li></ul> <p>根据事件循环机制，重新梳理一下流程：</p> <ul><li>执行一个宏任务（首次执行的主代码块或者任务队列中的回调函数）</li> <li>执行过程中如果遇到微任务，就将它添加到微任务的任务队列中</li> <li>宏任务执行完毕后，立即执行当前微任务队列中的所有任务（依次执行）</li> <li>JS引擎线程挂起，GUI线程执行渲染</li> <li>GUI线程渲染完毕后挂起，JS引擎线程执行任务队列中的下一个宏任务</li></ul> <h2 id="参考"><a href="#参考" class="header-anchor">#</a> 参考</h2> <p><a href="https://juejin.im/post/5cd9854b5188252035420a13" target="_blank" rel="noopener noreferrer">https://juejin.im/post/5cd9854b5188252035420a13<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> <a href="https://juejin.im/post/5b85b3326fb9a019fc76ecee" target="_blank" rel="noopener noreferrer">https://juejin.im/post/5b85b3326fb9a019fc76ecee<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> <a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/" target="_blank" rel="noopener noreferrer">https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/serina/blog/javascript/javascript1.html" class="prev">D3圆饼图</a></span> <!----></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/serina/assets/js/app.f947d9ec.js" defer></script><script src="/serina/assets/js/2.92704444.js" defer></script><script src="/serina/assets/js/10.b2a1b0fd.js" defer></script>
  </body>
</html>
